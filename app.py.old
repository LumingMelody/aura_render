from video_generate_protocol import BaseNode, EmotionAnalysisNode, ShotBlockGenerationNode, \
    BGMAanchorPlanningNode, AssetRequestNode, TransitionSelectionNode, FilterApplicationNode, \
    DynamicEffectsNode, BGMCompositionNode, SFXIntegrationNode, AudioProcessingNode, \
    AuxMediaInsertionNode, AuxTextInsertionNode, SubtitleNode, IntroOutroNode, TimelineIntegrationNode
from video_generate_protocol import VideoTypeIdentificationNode
from fastapi import FastAPI, BackgroundTasks,HTTPException
from fastapi.responses import JSONResponse
# from ai_content_pipeline.strategies import get_strategy
# from ai_content_pipeline.orchestrator.task_orchestrator import TaskOrchestrator

from pydantic import BaseModel, Field
from typing import Dict, Any, Optional,Tuple, List
import asyncio
import httpx
import logging
import uvicorn
import json


# =============================
# åŸºç¡€è®¾ç½®
# =============================

app = FastAPI(title="Video Production Pipeline API", version="1.0")

# æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# å›è°ƒåœ°å€ï¼ˆå¯é…ç½®ï¼‰
CALLBACK_URL = "http://192.168.10.16:1689/chat/notify"  # å¯æ›¿æ¢ä¸ºå®é™…å›è°ƒæœåŠ¡åœ°å€
SAVE_URL = "https://agent.cstlanbaai.com/gateway/admin-api/agent/global-key/create-or-update"
REDIS_SAVE_URL="http://192.168.10.16:1689/redis/add"


#=============================
# èŠ‚ç‚¹æ³¨å†Œåˆ—è¡¨
# =============================

NODES = [
    VideoTypeIdentificationNode("VideoTypeIdentificationNode"),
    EmotionAnalysisNode("EmotionAnalysisNode"),
    ShotBlockGenerationNode("ShotBlockGenerationNode"),
    BGMAanchorPlanningNode("BGMAanchorPlanningNode"),
    AssetRequestNode("AssetRequestNode"),
    TransitionSelectionNode("TransitionSelectionNode"),
    FilterApplicationNode("FilterApplicationNode"),
    DynamicEffectsNode("DynamicEffectsNode"),
    BGMCompositionNode("BGMCompositionNode"),
    SFXIntegrationNode("SFXIntegrationNode"),
    AudioProcessingNode("AudioProcessingNode"),
    AuxMediaInsertionNode("AuxMediaInsertionNode"),
    AuxTextInsertionNode("AuxTextInsertionNode"),
    SubtitleNode("SubtitleNode"),
    IntroOutroNode("IntroOutroNode"),
    TimelineIntegrationNode("TimelineIntegrationNode"),
]

# =============================
# å¼‚æ­¥å›è°ƒå‡½æ•°
# =============================

async def call_callback(task_id: str, node_index: int, status: str, message: str):
    """
    å‘æŒ‡å®šåœ°å€å‘é€æ ‡å‡†åŒ–å›è°ƒé€šçŸ¥

    :param task_id: ä»»åŠ¡IDï¼Œå¯¹åº”å­—æ®µ 'taskId'
    :param node_index: èŠ‚ç‚¹ç¼–å·ï¼Œç”¨äºç”Ÿæˆ key å¦‚ node1, node2...
    :param status: çŠ¶æ€å€¼ï¼Œå¡«å…¥ 'val' å­—æ®µï¼ˆå¦‚ "completed", "failed"ï¼‰
    :param message: æè¿°ä¿¡æ¯ï¼Œå¡«å…¥ 'des' å­—æ®µ
    """
    if status  == "failed":
        task_status=3
    else:
        task_status=2

    payload = {
        "taskId": task_id,
        "taskStatus":task_status,
        "key": f"node{node_index}",
        "val": status,
        "remark": message
    }

    async with httpx.AsyncClient(timeout=10.0) as client:
        try:
            response = await client.post(CALLBACK_URL, json=payload)
            if response.status_code == 200:
                logger.info(f"Callback succeeded for taskId={task_id}, node={node_index}")
            else:
                logger.warning(
                    f"Callback HTTP {response.status_code} for taskId={task_id}: {response.text}"
                )
        except Exception as e:
            logger.error(f"Callback failed for taskId={task_id}: {e}")



# =============================
# å¼‚æ­¥ä¿å­˜ global-key å‡½æ•°
# =============================
import asyncio
import httpx
import json
import logging
import re

logger = logging.getLogger(__name__)

# æ¥å£åœ°å€
SAVE_URL = "https://agent.cstlanbaai.com/gateway/admin-api/agent/global-key/create-or-update"
REDIS_SAVE_URL = "http://192.168.10.16:1689/redis/add"

def transform_key(key: str) -> str:
    """
    å°† xxx_id è½¬æ¢ä¸º xxx
    ä¾‹å¦‚: video_type_id -> video_type
    """
    return re.sub(r'_id$', '', key)

async def save_global_key(
    session_id: str,
    tenant_id: int,
    user_id: int,
    node_index: int,
    result: dict,
    global_value_desc: str = "Node execution result"
):
    """
    å°† result ä¸­æ¯ä¸ªå­—æ®µçš„ key ä¸­çš„ '_id' æ›¿æ¢ä¸º '_{session_id}'ï¼Œä½œä¸º globalKey ä¿å­˜
    """
    if not isinstance(result, dict):
        logger.warning("result must be a dict. Skipped.")
        return

    # å­˜å‚¨æ‰€æœ‰å¾…ä¿å­˜çš„ä»»åŠ¡
    tasks = []
    async with httpx.AsyncClient(timeout=15.0, verify=False) as client:
        for raw_key, value in result.items():
            # âœ… æ ¸å¿ƒé€»è¾‘ï¼šå°† key ä¸­çš„ '_id' æ›¿æ¢ä¸º '_{session_id}'
            if '_id' in raw_key:
                # ä¾‹å¦‚ï¼švideo_type_id -> video_type_sess_abc123
                new_key = raw_key.replace('_id', f'_{session_id}')
            else:
                # å¦‚æœä¸åŒ…å« _idï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä¿ç•™åŸ key æˆ–è·³è¿‡
                new_key = f"{raw_key}_{session_id}"
                logger.warning(f"Key '{raw_key}' does not contain '_id', using fallback key: '{new_key}'")

            # ========== 1. æ„å»º SQL æ¥å£è¯·æ±‚ ==========
            sql_payload = {
                "globalKey": new_key,
                "globalValue": json.dumps(value, ensure_ascii=False)
            }
            sql_headers = {
                "tenant-id": str(tenant_id),
                "Authorization": f"test{user_id}",
                "Content-Type": "application/json"
            }
            tasks.append(
                send_request(client, SAVE_URL, f"SQL:{new_key}", sql_payload, sql_headers)
            )

            # ========== 2. æ„å»º Redis æ¥å£è¯·æ±‚ ==========
            redis_payload = {
                "globalKey": new_key,
                "globalValue": json.dumps(value, ensure_ascii=False),
                "globalValueDesc": f"{global_value_desc} - {raw_key}",  # å¯åŒºåˆ†æ¥æºå­—æ®µ
                "userId": user_id,
                "tenantId": tenant_id
            }
            redis_headers = {
                "Content-Type": "application/json"
            }
            tasks.append(
                send_request(client, REDIS_SAVE_URL, f"Redis:{new_key}", redis_payload, redis_headers)
            )

        # å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰è¯·æ±‚
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for res in results:
            if isinstance(res, Exception):
                logger.error(f"Save request failed: {res}")


async def send_request(
    client: httpx.AsyncClient,
    url: str,
    task_name: str,
    payload: dict,
    headers: dict
):
    """
    å‘é€ HTTP è¯·æ±‚çš„é€šç”¨å‡½æ•°
    """
    try:
        response = await client.post(url, json=payload, headers=headers)
        if response.status_code in (200, 201):
            logger.info(f"[{task_name}] Saved successfully.")
            return True
        else:
            logger.warning(f"[{task_name}] Failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        logger.error(f"[{task_name}] Request failed: {e}")
        return False

# ç±»å‹æ˜ å°„è¡¨
TYPE_MAPPING = {
    str: "string",
    int: "integer",
    float: "number",
    bool: "boolean",
    list: "array",
    dict: "object",
    tuple: "array",
    List[Dict]: "list[dict]",
    Dict[str, Any]: "dict",
    type(None): "null",
}

def convert_schema_types(schema):
    """
    é€’å½’éå† schemaï¼Œå°†å­—æ®µä¸­çš„ 'type' å¯¹åº”çš„ Python ç±»å‹è½¬ä¸º JSON å¯åºåˆ—åŒ–çš„å­—ç¬¦ä¸²ã€‚
    """
    if isinstance(schema, list):
        return [convert_schema_types(item) for item in schema]
    elif isinstance(schema, dict):
        new_dict = {}
        for k, v in schema.items():
            if k == "type" and v in TYPE_MAPPING:
                new_dict[k] = TYPE_MAPPING[v]
            else:
                new_dict[k] = convert_schema_types(v)
        return new_dict
    else:
        return schema



# =============================
# åŠ¨æ€æ³¨å†Œè·¯ç”±å‡½æ•°ï¼ˆæ›´æ–°ç‰ˆï¼‰
# =============================

def register_node_routes(app: FastAPI, node: BaseNode, node_index: int):
    node_name = node.__class__.__name__.replace("Node", "").lower()

    # --- 1. Schema è·¯ç”± ---
    @app.get(f"/node{node_index}/schema", summary=f"Get schema for {node_name}")
    async def get_schema():
    

        # å‡è®¾è¿™æ˜¯ä½ åŸæ¥çš„è¿”å›æ•°æ®ï¼ˆåŒ…å« str, list, int ç­‰ç±»å‹å¯¹è±¡ï¼‰
        raw_schema = node.get_input_schema()
        
        # âœ… åœ¨è¿™é‡Œç»Ÿä¸€è½¬æ¢ type
        safe_schema = convert_schema_types(raw_schema)
        
        return JSONResponse(content=safe_schema)

    # --- 2. Generate è·¯ç”± ---
    class GenerateRequest(BaseModel):
        taskId: str = Field(..., description="ä»»åŠ¡å”¯ä¸€æ ‡è¯†ç¬¦")
        sessionId: str = Field(..., description="ä¼šè¯ID")
        userId: int = Field(..., description="ç”¨æˆ·ID")
        tenantId: int = Field(..., description="ç§Ÿæˆ·ID")
        context: Dict[str, Any] = Field(..., description="å¤„ç†ä¸Šä¸‹æ–‡")

    @app.post(f"/node{node_index}/generate", summary=f"Run generate on {node_name}")
    async def run_generate(request: GenerateRequest, background_tasks: BackgroundTasks):
        task_id = request.taskId
        session_id = request.sessionId
        user_id = request.userId
        tenant_id = request.tenantId

        logger.info(f"Received generate request for node {node_index}, taskId={task_id}, sessionId={session_id}")

        # ç«‹å³è¿”å›æ¥æ”¶ç¡®è®¤
        response = {"received": True, "taskId": task_id, "node": node_index}

        # åå°ä»»åŠ¡
        async def background_job():
            await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿå¼‚æ­¥å»¶è¿Ÿ
            try:
                # context = node.validate_context(request.context)
                # # æ‰§è¡ŒèŠ‚ç‚¹å¤„ç†
                # result = await node.generate(context)
                result = await node.generate(request.context)
                # 1. ä¿å­˜ç»“æœåˆ° global-key æ¥å£
                await save_global_key(
                    session_id=session_id,
                    tenant_id=tenant_id,
                    user_id=user_id,
                    node_index=node_index,
                    result=result
                )

                # 2. å‘é€æˆåŠŸå›è°ƒ
                await call_callback(
                    task_id=task_id,
                    node_index=node_index,
                    status="completed",
                    message=f"Node {node_index} completed and saved."
                )

            except Exception as e:
                error_msg = f"Node {node_index} failed: {str(e)}"
                logger.error(error_msg)

                # å¤±è´¥ä¹Ÿé€šçŸ¥ï¼ˆä¸ä¿å­˜å¤±è´¥ç»“æœï¼‰
                await call_callback(
                    task_id=task_id,
                    node_index=node_index,
                    status="failed",
                    message=error_msg
                )

        background_tasks.add_task(background_job)
        return response

# =============================
# æ³¨å†Œæ‰€æœ‰èŠ‚ç‚¹è·¯ç”±
# =============================

for idx, node in enumerate(NODES, start=1):
    register_node_routes(app, node, idx)

# =============================
# æ ¹è·¯å¾„å¥åº·æ£€æŸ¥
# =============================

@app.get("/")
def read_root():
    return {
        "message": "Video Pipeline API is running",
        "nodes": [f"node{i}" for i in range(1, 17)],
        "documentation": "/docs"
    }



# @app.post("/generate")
# async def generate_content(request: GenerateRequest):
#     strategy = get_strategy(request.strategy)
#     if not strategy:
#         raise HTTPException(404, "Strategy not found")

#     # æ„å»ºå·¥ä½œæµ
#     workflow = strategy.build_workflow(request.context)

#     # æ‰§è¡Œ
#     orchestrator = TaskOrchestrator(generator_pool=get_generator_pool())
#     result = await workflow.execute(orchestrator)

#     return result


# from matcher.main_video_matcher import match_main_video
# from matcher.bgm_matcher import match_bgm
# from matcher.sfx_matcher import match_sfx
# from matcher.font_matcher import match_font
# from matcher.supplement_matcher import match_supplement


# @app.post("/supply-main-video", response_model=List[VideoResponse])
# async def supply_main_video(request: VideoRequest):
#     try:
#         results = await match_main_video(request)
#         return results[:3]  # è¿”å› Top 3
#     except Exception as e:
#         raise HTTPException(500, detail=f"ä¸»è§†é¢‘åŒ¹é…å¤±è´¥: {str(e)}")

# @app.post("/supply-bgm", response_model=List[BGMResponse])
# async def supply_bgm(request: BGMRequest):
#     try:
#         results = await match_bgm(request)
#         return results[:3]
#     except Exception as e:
#         raise HTTPException(500, detail=f"BGM åŒ¹é…å¤±è´¥: {str(e)}")

# @app.post("/supply-sfx", response_model=List[SFXResponse])
# async def supply_sfx(request: SFXRequest):
#     try:
#         results = await match_sfx(request)
#         return results[:3]
#     except Exception as e:
#         raise HTTPException(500, detail=f"éŸ³æ•ˆåŒ¹é…å¤±è´¥: {str(e)}")

# @app.post("/supply-fonts", response_model=List[FontResponse])
# async def supply_fonts(request: FontRequest):
#     try:
#         results = await match_font(request)
#         return results
#     except Exception as e:
#         raise HTTPException(500, detail=f"å­—ä½“åŒ¹é…å¤±è´¥: {str(e)}")

# @app.post("/supply-extra-supplement", response_model=List[SupplementResponse])
# async def supply_extra_supplement(request: SupplementRequest):
#     try:
#         results = await match_supplement(request)
#         return results[:3]  # è¿”å› Top 3 è¾…åŠ©ç´ æ
#     except Exception as e:
#         raise HTTPException(500, detail=f"è¾…åŠ©ç´ æåŒ¹é…å¤±è´¥: {str(e)}")


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8100, log_level="info")
    # uvicorn.run(app, host="0.0.0.0", port=8100)
    # uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
    

    ##1 VideoTypeIdentificationNodeæµ‹è¯•

    # node= VideoTypeIdentificationNode("video_type_node")
    # context = {"theme": "pythonæ•™å­¦", "keywords": ["python", "æ•™å­¦"], "target_duration": 60}
    # result = node.generate(context)
    # print(f"Generated video type: {result['video_type']}")


    ##2 EmotionAnalysisNodeæµ‹è¯•
    # emotion_node = EmotionAnalysisNode(node_id="emotion_1", name="æƒ…æ„ŸåŸºè°ƒåˆ†æèŠ‚ç‚¹")

    # # 2. æ¨¡æ‹Ÿä¸Šæ¸¸èŠ‚ç‚¹ä¼ æ¥çš„ä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰
    # context = {
    #     "user_description": "æˆ‘æƒ³åšä¸€ä¸ªpythonçš„æ•™å­¦è§†é¢‘",
    #     "video_type": "æ•™è‚²ç±»"
    # }

    # # 3. è°ƒç”¨ generate æ–¹æ³•è¿›è¡Œæƒ…æ„Ÿåˆ†æ
    # try:
    #     result = emotion_node.generate(context)
    #     print("âœ… æƒ…æ„Ÿåˆ†æç»“æœï¼š")
    #     print(result)  # è¾“å‡º: {'emotions': {'æ¸©é¦¨': 60, 'æ„ŸåŠ¨': 30, 'å¹½é»˜': 10}}
    # except Exception as e:
    #     print(f"âŒ æ‰§è¡Œå¤±è´¥ï¼š{e}")

    ##3 ShotBlockGenerationNodeæµ‹è¯•
    # # åˆ›å»ºèŠ‚ç‚¹
    # node = ShotBlockGenerationNode(node_id="shot_gen_1", name="AIåˆ†é•œç”Ÿæˆå™¨")
    # context = {
    #     "emotions": {
    #         'emotions': {'åŠ±å¿—': 45, 'å†·é™': 33, 'æ¿€æ˜‚': 22}
    #     },
    #     "video_content": {
    #         "video_type": "æ•™è‚²ç±»",
    #         "structure_template": {
    #             "intro": "å¿«é€Ÿä»‹ç»Pythonç¼–ç¨‹è¯­è¨€çš„é‡è¦æ€§ä»¥åŠæœ¬æ¬¡æ•™å­¦çš„ç›®æ ‡ï¼Œå¸å¼•è§‚ä¼—å…´è¶£ã€‚",
    #             "body": "é€‰å–ä¸€ä¸ªç®€å•çš„Pythonç¤ºä¾‹ï¼ˆå¦‚æ‰“å°'Hello, World!'ï¼‰ï¼Œä»ç¯å¢ƒæ­å»ºåˆ°ä»£ç ç¼–å†™è¿‡ç¨‹é€æ­¥æ¼”ç¤ºï¼Œå¹¶è§£é‡Šæ¯ä¸€æ­¥çš„ä½œç”¨ã€‚",
    #             "conclusion": "å›é¡¾æ‰€å­¦å†…å®¹ï¼Œå¹¶é¼“åŠ±è§‚ä¼—å°è¯•è‡ªå·±åŠ¨æ‰‹å®è·µï¼ŒåŒæ—¶é¢„å‘Šä¸‹ä¸€èŠ‚è¯¾ç¨‹çš„å†…å®¹æˆ–ä¸»é¢˜ã€‚"
    #         }
    #     },
    #     "target_duration": 60  # å¯é€‰æ³¨å…¥
    # }

    

    # # è°ƒç”¨ generate
    # result = node.generate(context)

    # print("ğŸ¬ åˆ†é•œç”Ÿæˆç»“æœï¼š\n")
    # for i, block in enumerate(result["shot_blocks"]):
    #     print(f"é•œå¤´ {i+1}:")
    #     print(f"  æ—¶é•¿: {block['duration']}s [{block['start_time']} â†’ {block['end_time']}]")
    #     print(f"  é•œå¤´: {block['shot_type']} | èŠ‚å¥: {block['pacing']}")
    #     print(f"  ç”»é¢: {block['visual_description']}")
    #     print(f"  å­—å¹•: {block['caption']}")
    #     print("-" * 60)

